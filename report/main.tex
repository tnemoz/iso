\documentclass[11pt, a4paper]{article}

\newcommand{\reporttitle}{Quantum programming}
\newcommand{\reportauthor}{Tristan \textsc{Nemoz}}
\newcommand{\reporttype}{Individual Study Option}
\newcommand{\reportemail}{tristan.nemoz19@imperial.ac.uk}
\newcommand{\cid}{01811909}
\date{April 30, 2020}

\author{Tristan \textsc{Nemoz}\\Imperial College London\\MSc Computing (Security \& Reliability\\\href{mailto:tristan.nemoz19@imperial.ac.uk}{\texttt{tristan.nemoz19@imperial.ac.uk}}}
\title{A generic quantum circuit for a recommendation system}

\input{includes} % various packages needed for maths etc.

\begin{document}
	\input{titlepage.tex}
	\maketitle
    \begin{abstract}
        In this work, we design a generic quantum circuit to implement a recommendation system following the algorithm of \citeauthor{QRS}. This algorithm takes as input a \(m\times n\) binary matrix which has a good rank-\(k\) approximation and returns a product recommendation for an user in time \(O(\log(k)\,\polylog(m\,n))\).
        
        We discuss the limitations of implementing this algorithm on a real quantum computer and the differences between the high-level description of the algorithm and its low-level implementation. In particular, we discuss on the reasons that could improve our design's complexity in the future.
    \end{abstract}
    
    \section{Introduction}
        In spite of the lack of actual quantum computers, quantum computing has been studied for several dozens of year because of its promising results. Since the proposal of an algorithm for prime factorization \cite{Shor} by \citeauthor{Shor} in 1997, several other quantum algorithms were designed to provide a solution to classical problems with an exponential speed-up in complexity.
        
        Amongst them is the HHL algorithm \cite{HHL} whose goal is to solve a linear system \(\mathbf{A}\,\mathbf{x}=\mathbf{y}\) where \(\mathbf{A}\in\mathbf{R}^{n\times n}\) in time \(O\left(\log(n)\,\kappa^2\right)\), \(\kappa\) being the condition number of \(\mathbf{A}\). Further studies of this algorithm generalized its routines to apply them to other problems. For instance, creating efficiently a quantum state \(\ket{x}\) corresponding to a real vector \(\mathbf{x}\in\mathbf{R}^n\), which is essential to use the algorithm, has been found to be possible using Quantum RAM \cite{Prakash, QRAM, QRAMCircuit}.
        
        HHL algorithm was one of the first algorithms to use Quantum Computing for solving a Machine Learning problem. Other followed and papers have continued to be published to apply Quantum Computing to specific Machine Learning tasks like Deep Convolutional Neural Networks \cite{QCNN}.
        
        In a similar way of the P=NP problem, we currently do not know how to determine whether a problem is only solvable in logarithmic complexity with a quantum computer. For instance, Shor's algorithm \cite{Shor} does not have a classical equivalent that matches its complexity yet. However, a recent paper from \citeauthor{Dequantized} shows that the Quantum Recommendation system is not one of those. Indeed, they provide a classical algorithm for doing the same task classically in time complexity \(O(\poly(k)\,\log(m\,n))\), which is only slower by a polynomial factor than its quantum equivalent. Still, the goal of this paper is to highlight the differences between the theoretic implementation of an algorithm and its real-world implementation, and the Quantum Recommendation System algorithm is a good example for this purpose.
        
        In this context, \citeauthor{QRS} proposed in 2016 a quantum algorithm for a recommendation system which provided a solution with an exponential speed-up gain in time complexity regarding classical solutions at that time. Indeed, the classical solutions required to compute a \(m\times n\) matrix from which the recommendations were made \cite{Amazon}, which means that their complexity was at least \(O(m\,n)\). The algorithm described in \cite{QRS} by \citeauthor{QRS} however, has a time complexity of \(O(\log(k)\,\polylog(m\,n))\). Since it does not have to write down neither the entire matrix nor even a row vector from this matrix, it is not subject to the same linear complexity as its classical equivalent.
        
        We present a generic quantum circuit for implementing this algorithm so that it can be easily reproducible using any framework, given an implementation of a Quantum RAM, that is, a general circuit made of elementary gates that matches the original algorithm. Because of the limitations of the quantum hardware, which are discussed in \autoref{subsec:Hardware}, only a limited set of gates can be used. Furthermore, some operations used in the original algorithm are not currently possible to implement on a quantum computer. For such problems, we present workarounds that leave the complexity untouched but cut the probability of success of the algorithm. One problem couldn't be tackled though, which is the lack of an actual quantum ram implementation. As a consequence, our implementation's complexity matches the original algorithm' one of \(O(\polylog(m\,n)\,\poly(k))\) if and only if the Quantum RAM can be accessed in a superposed state, and succeeds with only a probability of \(1-\frac{1}{\log(m\,n)}\), where the original algorithm succeeds with probability \(1 - \frac{1}{\poly(m\,n)}\).
        
        Hence, our goal is to present the differences between a theoretic implementation of the algorithm of \citeauthor{QRS} and a currently real one.
        
        This paper is organized as follows:
        
        \begin{enumerate}
         \item In \autoref{sec:QC}, we provide the reader with basics of Quantum Computing, so that this document is \textit{mostly} self-contained.
         \item In \autoref{sec:QRS}, we provide a high-level description of the algorithm of \citeauthor{QRS}, as well as a formal mathematical definition of the problem. We also present in this section the challenges to be tackled.
         \item In \autoref{sec:QCircuit}, we present our solutions to cope with these problems when implementing the algorithm on a real quantum computer.
        \end{enumerate}

    \section{Quantum computing preliminaries}
        \label{sec:QC}
        In this section, we ought to present the fundamentals of Quantum Computing that will be used throughout this document in \autoref{subsec:QCT}. Note that only the notions that will be used in the actual implementation of the algorithm will be presented.
        
        Once the formalism of Quantum Computing presented, we discuss the limitations enforced by the current quantum computers in \autoref{subsec:Hardware}.
        \subsection{Quantum computing theory}
            \label{subsec:QCT}
            The principle of Quantum Computing is to design a formalism so that one can encode information as binary words, just like in classical computing. Linking this formalism to the physics principles is a problem we will not discuss here, but whose history is summarized in \cite{HistoryEquivalence}.
            \subsubsection{Quantum computing objects}
                Quantum computing operates with qubits, which are unitary vectors of \(\mathbf{C}^2\). Such a vector represent a quantum particle state which we denote \(\ket{x}\). A quantum register is defined as a group of qubits. We define \(\ket{0}\) and \(\ket{1}\) to be the vectors of the computational basis of \(\mathbf{C}^2\) seen as a \(\mathbf{C}\)-vector field. As such, given \(\ket{x}\in\mathbf{C}^2\) we can write:
                
                \[\ket{x} = \begin{pmatrix}\alpha\\\beta\end{pmatrix}=\alpha\,\begin{pmatrix}1\\0\end{pmatrix} + \beta\,\begin{pmatrix}0\\1\end{pmatrix}=\alpha\,\ket{0} + \beta\,\ket{1}\]
                
                with \(\alpha\,\overline{\alpha} + \beta\,\overline{\beta} = 1\). \ket{x} is then said to be a superposition of the vector of the computational basis.
                
                For a given matrix \(\mathbf{A}\), we define \(\mathbf{A}^\dagger\) to be the conjugate of the transposed matrix of \(\mathbf{A}\), that is:
                
                \[\mathbf{A}^\dagger \overset{\text{\tiny{def}}}{=} \overline{\mathbf{A}^\top} = \overline{\mathbf{A}}^\top\,.\]
                
                Similarly, we define \bra{x} to be:
                
                \[\bra{x}\overset{\text{\tiny{def}}}{=}\ket{x}^\dagger\,.\]
                
                Each quantum state \(\ket{x}\) evolution satisfies Schrödinger's equation:
                
                \[\mathrm{i}\,\hbar\,\frac{\partial}{\partial t}\ket{x} = \mathbf{H}\,\ket{x}\]
                
                with \(\mathbf{H}\) being a self-adjoint matrix:
                
                \[\mathbf{H}^\dagger=\mathbf{H}\,.\]
                
                The solution to Schrödinger's equation is given by \(\exp\left(-\frac{\mathrm{i}}{\hbar}\,\mathbf{H}\,t\right)\), which is unitary:
                
                \[\exp\left(-\frac{\mathrm{i}}{\hbar}\,\mathbf{H}\,t\right)^\dagger\,\exp\left(-\frac{\mathrm{i}}{\hbar}\,\mathbf{H}\,t\right) = \mathbf{I}\,.\]
                
                As a consequence, every operation \(\mathbf{U}\) performed on a quantum state \(\ket{x}\) must be unitary. Reciprocally, every unitary matrix \(\mathbf{U}\) can be applied to a quantum state \(\ket{x}\). Such an operation is called a quantum gate. 
                
                A quantum algorithm operates with several qubits. Let \ket{\varphi} and \ket{\psi} be two qubits. Then the quantum state containing \ket{\varphi} in a first register and \ket{\psi} in a second register is given by the tensor product \(\ket{\varphi}\otimes\ket{\psi}\) of \ket{\varphi} and \ket{psi}. An usual convention is to omit the symbol of the tensor product. Hence, such a state would be noted \(\ket{\varphi}\,\ket{\psi}\), or even \ket{\phi\psi}. Then, if a gate \(\mathbf{U}_1\) is applied on \ket{\varphi}, and a gate \(\mathbf{U}_2\) is applied on \ket{\psi}, then the resulting quantum state is given by:
                
                \[\left(\mathbf{U}_1\otimes\mathbf{U}_2\right)\,\left(\ket{\varphi}\otimes\ket{\psi}\right)\,.\]
                
                To make an analogy with classical computing, a quantum algorithm encodes information as a tensor product of several qubits, apply one or more quantum gates to them, and then read out the result. Both the input and the output of a quantum algorithm is a tensor product of qubits, each possibly in a superposed state.
                
                The big difference with classical computing however, is that every operation performed on a quantum state is reversible, since every operation is represented by a unitary, hence invertible, matrix. The only exception to this rule is the reading operation, also called the Measurement operation, described in \autoref{subsubsec:Measurement}.
            \subsubsection{Quantum circuit}
                Let \ket{x} and \ket{y} be two qubits and let \(\mathbf{U}_1\), \(\mathbf{U}_2\) and \(\mathbf{U}_3\) be three quantum gates that can be applied on single qubits. Applying \(\mathbf{U}_1\) followed by \(\mathbf{U}_2\) on \ket{x} while applying \(\mathbf{U}_3\) to \ket{y} is graphically represented as shown below:
                
                \begin{figure}[ht]
                    \centering
                        \begin{quantikz}
                            \lstick{\ket{x}} & \gate{\mathbf{U}_1} & \gate{\mathbf{U}_2} & \qw\\
                            \lstick{\ket{y}} & \gate{\mathbf{U}_3} & \qw & \qw
                        \end{quantikz}
                    \caption{An example of a quantum circuit}
                \end{figure}
                
                or equivalently, since \(\mathbf{U}_1\otimes\mathbf{U}_2\) is a \(2^2\times2^2\) unitary matrix, and as such is a quantum gate that operates on two qubits:
                
                \begin{figure}[ht]
                    \centering
                        \begin{quantikz}
                            \lstick{\ket{x}} & \gate[wires=2]{\mathbf{U}_1\otimes\mathbf{U}_3} & \gate{\mathbf{U}_2} & \qw\\
                            \lstick{\ket{y}} &  & \qw & \qw
                        \end{quantikz}
                    \caption{An example of a quantum circuit with a gate applied on several qubits}
                \end{figure}
                
                It is possible to apply a gate on a given qubit \ket{y} only if another qubit is in the state \ket{1}. Such a gate is called a controlled gate. Let us take the following circuit as an example:
                
                \begin{figure}[ht]
                    \centering
                        \begin{quantikz}
                            \lstick{\ket{x}} & \ctrl{1} & \qw\\
                            \lstick{\ket{y}} & \gate{\X}  & \qw &
                        \end{quantikz}
                    \caption{An example of a quantum circuit with a conditoned gate}
                \end{figure}
                
                Here, \(\X\) is the Pauli \(\X\)-gate, which will be extensively used throughout this document:
                
                \[\X\overset{\text{\tiny{def}}}{=}\begin{pmatrix}0 & 1\\ 1 & 0\end{pmatrix}\,.\]
                
                \(\X\) is also called the NOT gate, since it maps the state \ket{0} to the state \ket{1} and reciprocally. Let us write \ket{x} as \(\ket{x}=x_1\,\ket{0}+x_2\ket{1}\) and \ket{y} as \(y_1\,\ket{0} + y_2\,\ket{1}\). Then the global quantum state at the beginning of this circuit is given by:
                
                \[\ket{x}\otimes\ket{y} = x_1\,y_1\,\ket{00} + x_1\,y_2\,\ket{01} + x2\,y_1\,\ket{10} + x_2\,y_2\,\ket{11}\,.\]
                
                Applying \(\X\) conditioned on \ket{x} means that the gate will be applied on the parts of the state that have \ket{0} on their first qubits. Hence, the resulting state of this circuit is:
                
                \[x_1\,y_1\,\ket{00} + x_1\,y_2\,\ket{01} + x2\,y_2\,\ket{10} + x_2\,y_1\,\ket{11}\,.\]
                
                Note that for convenience purposes, it is also possible to apply a gate when a given qubit is in the state \ket{0}, which we represent like this:
                
                 \begin{figure}[ht]
                    \centering
                        \begin{quantikz}
                            \qw & \octrl{1} & \qw &\ghost{\X}\\
                            \qw & \gate{\mathbf{U}}  & \qw &
                        \end{quantikz}\(\equiv\)
                        \begin{quantikz}
                            \qw & \gate{\X} & \ctrl{1} & \gate{\X} & \qw\\
                            \qw & \qw & \gate{\mathbf{U}} & \qw
                        \end{quantikz}
                    \caption{An example of a quantum circuit with a gate conditioned on the state \ket{0}}
                \end{figure}
            \subsubsection{Measurement}
                \label{subsubsec:Measurement}
                Let \ket{x} be a quantum state of \(n\) qubits. We denote by \ket{k} the \(k\)\textsuperscript{th} vector of the computational basis of \(\mathbf{C}^{2^n}\). The notation \ket{k} will always be used in a non-ambiguous way. Indeed, it will only be used to write a quantum state whose number of qubits is known. As such, we have:
                
                \[\ket{x} = \sum_{k=1}^n\alpha_k\,\ket{k}\]
                
                with \(\alpha_k\in\mathbf{C}\) for \(k\in\llbracket1\,;\,n\rrbracket\). Measuring \ket{x} in the computational basis means projecting \ket{x} onto one vector of the computational basis of \(\mathbf{C}^{2^n}\). Measuring is the only operator that one is allowed to apply on a quantum state that is not unitary. The state onto which \ket{x} is mapped is randomly determined by its associated coefficient. More clearly, \ket{x} will be mapped on the state \ket{k} with probability \(\alpha_k\,\overline{\alpha_k}\). The measurement allows us to classically known onto which state \ket{x} has been projected. The representation of a measurement in a quantum circuit is the following:
                
                \begin{figure}[ht]
                    \centering
                        \begin{quantikz}
                            \qw & \meter{} & \qw\\
                        \end{quantikz}
                    \caption{Representation of a measurement}
                \end{figure}
                
                Measuring is usually the last thing performed in a quantum algorithm, since it is the only way to go from a quantum state to a classical one. However, a quantum algorithm designed to be used a part of another, bigger, quantum algorithm, does not necessarily perform a measurement. The HHL algorithm \cite{HHL} is often used as such.
                
                Note that the way it is performed, measuring a state is not sensible to the global phase of a quantum state. For instance, let us consider a state \ket{\psi}:
                
                \[\ket{\psi} = \alpha\,\ket{0}+\beta\,\ket{1}\,.\]
                
                Then \ket{psi} can be rewritten as follows:
                
                \[\ket{\psi}=\mathrm{e}^{\mathrm{i}\,\gamma}\,\left(\cos\left(\theta\right)\,\ket{0} + \mathrm{e}^{\mathrm{i}\,\delta}\,\sin\left(\theta\right)\,\ket{1}\right)\]
                
                with \((\gamma,\theta,\delta)\in\mathbf{R}^3\). The global phase shift \(\mathrm{e}^{\mathrm{i}\,\gamma}\) is physically irrelevant, as unobservable \cite{Berta}.
            \subsubsection{Entanglement}
                A state \ket{x} is entangled whenever it is not possible to find \(n\) qubits \ket{q_1}, \ket{q_2}, \(\cdots\), \ket{q_n} such that:
                
                \[\ket{x}=\bigotimes_{k=1}^n\ket{q_k}\,.\]
                
                But why is entanglement important? Let us consider the following circuit:
                
                \begin{figure}[ht]
                    \centering
                        \begin{quantikz}
                            \lstick{\ket{0}} & \gate{\mathbf{H}} & \ctrl{1} & \meter{} & \qw\\
                            \lstick{\ket{0}} & \qw & \gate{\X}  & \qw & \qw
                        \end{quantikz}
                    \caption{A quantum circuit for a demonstration of the impact of entanglement on measuring}
                \end{figure}
                
                Here, \(\mathbf{H}\) is the Hadamard gate, which maps \ket{0} to \(\frac{1}{\sqrt{2}}\,(\ket{0} + \ket{1})\). Hence, just before the measurement, the quantum state is given by:
                
                \[\ket{\varphi}=\frac{1}{\sqrt{2}}\,\ket{00} + \frac{1}{\sqrt{2}}\,\ket{11}\,.\]
                
                When measuring \ket{\varphi}, we will obtain \ket{0}  with probability \(\frac12\) or \ket{1} also with probability \(\frac12\). But even though we only measured the first qubit, we forced \ket{\varphi} to be either in the state \ket{00} or \ket{11} after the measurement. Hence, measuring the first qubit affected somehow the second qubit.
                
                Often, efficient quantum algorithms make use of entangled state. For this reason, it is crucial to ensure when measuring a quantum state that it is not entangled.
            \subsubsection{Quantum gates and algorithms}
                Since a quantum algorithm is actually applications of quantum gates, we can show that it is of course also unitary. For this reason, we often do not make the difference between a quantum gate and a quantum algorithm, especially when no measurement is performed.
                
                We need to introduce some gates that will be used in our implementation and provide their complexity. We define a set of elementary gates:
                
                \[\begin{array}{ccccccc}\X\overset{\text{\tiny{def}}}{=}\begin{pmatrix}0 & 1\\1 & 0\end{pmatrix} & \mathrm{H}\overset{\text{\tiny{def}}}{=}\frac{1}{\sqrt{2}}\begin{pmatrix}1 & 1\\1 & -1\end{pmatrix}&\mathrm{R}_{z}(\theta)\overset{\text{\tiny{def}}}{=}\begin{pmatrix}1 & 0\\0 & \mathrm{e}^{\mathrm{i}\,\theta}\end{pmatrix}&\mathrm{R}_y(\theta)\overset{\text{\tiny{def}}}{=}\begin{pmatrix}\cos\left(\frac\theta2\right) & -\sin\left(\frac\theta2\right)\\\sin\left(\frac{\theta}{2}\right) & \cos\left(\frac\theta2\right)\end{pmatrix}\end{array}\]
                
                with \(\theta\in\mathbf{R}\). For every matrix \(\mathbf{U}\) in this elementary set, we also define its controlled equivalent \(\mathsf{C}-\mathbf{U}\) as elementary. Note that this does not include \(\mathsf{C}-\mathrm{U}\) itself: a gate that is controlled on more than 2 qubits must be implemented using gates controlled on a single qubit. Finally, we add one more elementary gate (without adding its controlled equivalent), which is the Toffoli gate \(\mathsf{CC}-\mathbf{X}\), also known as the CCNOT gate. Its circuit representation is:
                
                \begin{figure}[ht]
                    \centering
                    \begin{quantikz}
                        \qw & \ctrl{2} & \qw\\
                        \qw & \ctrl{1} & \qw\\
                        \qw & \gate{\X} & \qw
                    \end{quantikz}
                    \caption{The Toffoli gate}
                \end{figure}
                
                Hence, the set \(\mathcal{E}\) of elementary gates is:
                
                \[\mathcal{E} \overset{\text{\tiny{def}}}{=} \{\mathbf{X}, \mathbf{R}_z(\theta), \mathbf{R}_y(\theta), \mathsf{C}-\mathbf{X}, \mathsf{C}-\mathbf{R}_z(\theta), \mathsf{C}-\mathbf{R}_y(\theta), \mathsf{CC}-\mathbf{X}\}\,.\]
                
                \begin{assumption}
                    \label{assumption:Elementary}
                    Every gate of \(\mathcal{E}\) can be implemented in \(O(1)\).
                \end{assumption}
                
                \thref{assumption:Elementary} ensures that we can compute the complexity of a quantum algorithm by decomposing it in a circuit that contains only elementary gates. For instance, a quantum algorithm with time complexity \(O(\poly(n))\) uses a polynomial number in \(n\) of consecutive gates. Note that gates can be applied in parallel. For instance, the circuit depicted in \autoref{figure:parallel} has a time complexity of \(O(1)\) while the one in \autoref{figure:linear} has a time complexity of \(O(n)\).
                
                \begin{figure}[ht]
                    \centering
                    \begin{quantikz}
                        \lstick{\ket{q_1}} & \gate{\mathbf{U}_1} & \qw\\
                        \lstick{\ket{q_2}} & \gate{\mathbf{U}_2} & \qw\\
                        \vdots&&&\\
                        \lstick{\ket{q_n}} & \gate{\mathbf{U}_n} & \qw\\
                    \end{quantikz}
                    \caption{An example of parallel computation}
                    \label{figure:parallel}
                \end{figure}
                                
                \begin{figure}[ht]
                    \centering
                    \begin{quantikz}
                        \lstick{\ket{q_1}} & \gate{\mathbf{U}_1} & \gate{\mathbf{U}_2}&\qw&\cdots& &\gate{\mathbf{U}_n}&\qw\\
                    \end{quantikz}
                    \caption{An example of a circuit with \(O(n)\) time complexity}
                \end{figure}

                Of course, these examples assume that all the \(\mathbf{U}_i\) are elementary gates.
                
                That said, the first gate we introduce is the SWAP gate, whose utility will be described in \autoref{subsec:Hardware}.
                
                \begin{definition}[SWAP gate]
                    The swap gate is used to exchange the value of two qubits. It is implemented as shown on \autoref{figure:swap}.
                    
                    \begin{figure}[ht]
                        \centering
                        \begin{quantikz}
                            \qw & \swap{1} & \qw &\ghost{\X}\\
                            \qw & \targX{}  & \qw &\ghost{\X}
                        \end{quantikz}\(\equiv\)
                        \begin{quantikz}
                            \qw & \gate{\X} & \ctrl{1} & \gate{\X} & \qw\\
                            \qw & \ctrl{-1} & \gate{\X} & \ctrl{-1} & \qw
                        \end{quantikz}
                        \caption{The SWAP gate}
                        \label{figure:swap}
                    \end{figure}
                    Hence, the time complexity of a SWAP gate is also \(O(1)\).
                \end{definition}
                
                We will need to add more control qubits to our gates. Hence, we describe how to apply a gate on a qubit controlled by \(n\) other qubits.
                
                \begin{definition}[\(n\)-controlled gate]
                    Let \(\mathbf{U}\) be a unitary and \(n\in\mathbf{N}\). Then it is possible to implement a gate \(\mathsf{C}^n-\mathbf{U}\) that acts on \(n+1\) qubits such that \(\mathbf{U}\) is applied to the \(n+1\)\textsuperscript{th} qubit if and only if the \(n\) other qubits are in state \ket{1} in polynomial time. The proof and the decomposition is given in \cite{Braida}.
                \end{definition}
                
                We also introduce the Quantum Fourier Transform gate. Its only use is within the Quantum Phase Algorithm, but by decomposing things like this, the complexity analysis becomes clearer.

                \begin{definition}[Quantum Fourier Transform]
                    The Quantum Fourier Transform gate \(\mathbf{F}\) matches the classical definition of the Fourier transform. Hence, we have, for \(n\) qubits:
                    
                    \[\forall j\in\left\llbracket0\,;\,2^n-1\right\rrbracket,\mathbf{F}\,\ket{j} = \frac{1}{\sqrt{2^n}}\,\sum_{k=0}^{2^n-1}\mathrm{e}^{\frac{2\,\mathrm{i}\,\pi\,k\,j}{2^n}}\,\ket{k}\]
                    
                    Its implementation is given in \cite{QCAQI}:
                    
                    \begin{figure}[ht]
                        \centering
                        \begin{quantikz}
                            \qw & \gate{\mathbf{H}} & \gate{\mathbf{R}_2} & \qw & \cdots & & \gate{\mathbf{R}_{n-1}} & \gate{\mathbf{R}_n} & \qw & \qw & \cdots & & \qw & \qw & \qw & \swap{4} & \qw & \qw\\
                            \qw & \qw & \ctrl{-1} & \qw & \cdots & & \qw & \qw & \gate{\mathbf{H}} & \qw & \cdots & & \qw & \qw & \qw & \qw & \swap{2} & \qw\\
                            \vdots\\
                            \qw & \qw & \qw & \qw & \cdots & & \ctrl{-3} & \qw & \qw & \qw & \cdots & & \gate{\mathbf{H}} & \gate{\mathbf{R}_2} & \qw & \qw & \targX{} & \qw\\
                            \qw & \qw & \qw & \qw & \cdots & & \qw & \ctrl{-4} & \qw & \qw & \cdots & & \qw & \ctrl{-1} & \gate{H} & \targX{} & \qw & \qw\\
                        \end{quantikz}
                        \caption{Implementation of the Quantum Fourier Transform}
                    \end{figure}
                    
                    where \(\mathbf{H}\) is the Hadamard gate:
                    
                    \[\mathbf{H}\overset{\text{\tiny{def}}}{=}\frac{1}{\sqrt{2}}\begin{pmatrix}1 & 1\\1 & -1\end{pmatrix}\]
                    
                    and where \(\mathbf{R}_k\) is defined as, for \(k\in\llbracket2\,;\,n\rrbracket\):
                    
                    \[\mathbf{R}_k\overset{\text{\tiny{def}}}{=}\begin{pmatrix}1 & 0\\0 & \mathrm{e}^{\frac{2\,\mathrm{i}\,\pi}{2^k}}\end{pmatrix}\,.\]
                    
                    We assume both gates can be implemented in \(O(1)\).
                    
                    Note that is it possible to see \(\mathbf{F}\) implemented without the SWAP gates at the end for performance reasons. Thanks to this decomposition, we can implement \(\mathbf{F}\) in time \(O\left(n^2\right)\).
                \end{definition}
                
                As said earlier, the utility of defining the Quantum Fourier Transform is to use it within the Quantum Phase Estimation Algorithm, whose goal is to estimate the eigenvalue of a given unitary matrix associated to a given eigenvector of this matrix.
                
                \begin{definition}[Quantum phase estimation]
                    Let \(\mathbf{U}\) be a unitary matrix. Let \ket{\psi} be an eigenvector of \(\mathbf{U}\) associated to the eigenvalue \(\mathrm{e}^{2\,\mathrm{i}\,\pi\,\theta}\), with \(\theta\in[0\,;\,1]\). Let be \(\varepsilon\in\mathbf{R}_+^*\). Let \(\overline{\theta}\) be the best approximation of \(\theta\) on \(n=\left\lceil\log_2(\frac1\varepsilon)\right\rceil\) bits, that is:
                    
                    \[\left\|\theta-\overline{\theta}\right\|_1\leqslant\varepsilon\,.\]
                    
                    Then with probability at least \(\frac{4}{\pi^2}\), the Quantum Phase Estimation algorithm maps the state \(\ket{0}^{\otimes n}\,\ket{\psi}\) to the state \(\ket{\overline{\theta}}\,\ket{\psi}\) in time \(O\left(2^n\,n^2\,T_\mathbf{U}\right)\), where \(T_{\mathbf{U}}\) is the time taken for implementing \(\mathbf{U}\).
                    
                    The actual implementation of the \(\mathbf{QPE}\) gate using \(\mathbf{QFT}^\dagger\) is well-known in the literature, and presented for instance in \cite{QPE}. Its quantum circuit is the following one:
                    
                    \begin{figure}[ht]
                        \centering
                        \begin{quantikz}
                            \lstick{\ket{q_1}} & \gate{\mathbf{H}} & \qw & \qw & \qw & \cdots & & \ctrl{3} & \gate[wires=4]{\mathbf{F}^\dagger} & \meter{}\\[1cm]
                            \lstick{\ket{q_{n-1}}} & \gate{\mathbf{H}} & \qw & \ctrl{2} & \qw & \cdots & & \qw & & \meter{}\\
                            \lstick{\ket{q_n}} & \gate{\mathbf{H}} & \ctrl{1} & \qw & \qw & \cdots & & \qw & & \meter{}\\
                            \lstick{\ket{\psi}} & \qw & \gate{\mathbf{U}} & \gate{\mathbf{U}^2} & \qw & \cdots & & \gate{\mathbf{U}^{2^{n-1}}} & \qw & \qw
                        \end{quantikz}
                        \caption{Quantum circuit for the Quantum Phase Estimation algorithm}
                    \end{figure}
                    The \(\mathbf{H}\) gates are all applied in \(O(1)\), and we know that \(\mathbf{F}^\dagger\) is applied in time \(O(n^2)\). However, the controlled gate \(\mathbf{U}^{2^k}\) is implemented by concatenating \(\mathbf{U}\) to itself \(2^k\) times. As such, the total number of gates used for this step is \(T_{\mathbf{U}\left(2^n-1\right)}\). Hence, the complexity of this circuit is \(O\left(2^n\,n^2\,T_{\mathbf{U}}\right)\).
                \end{definition}
                
                Finally, we will need to apply an arbitrary function on a quantum state. Since a quantum gate has to be reversible, there is a common trick to define such a gate.
                
                \begin{definition}[Gate of a real function]
                    Let \(f:\{0\,;\,1\}^n\to\{0\,;\,1\}^m\) be an arbitrary function on bit strings. Then, the gate:
                    
                    \[\mathbf{U}_f:\ket{x}\,\ket{y}\mapsto\ket{x}\ket{x\oplus y}\]
                    
                    is unitary. If \(f\) is efficiently computable, then so is \(\mathbf{U}_f\). A way to perform this can be to decompose \(f\) using its Taylor expansion, or simply to translate the classical circuit for computing \(f\) into a quantum circuit.
                \end{definition}

        \subsection{Quantum hardware considerations}
            \label{subsec:Hardware}
            Whilst the previous formalism is useful to design quantum gates, it is important to keep in mind that some operations are not allowed, or are subject to some limitations because of current quantum hardware. These limitations are the difference between the theoretic algorithm and its actual implementation and as such, the reason of this paper. Three of them are particularly important.
            
            First of all, only a limited set of gates can be implemented. For instance, Google’s Xmon devices only supports the \(\mathbf{Z}\) gate, the \(\mathsf{C}-\mathbf{Z}\) gate and a more general version of the \(\X\) gate. This is not of great importance, as long as we can define every gate in \(\mathcal{E}\) from every allowed gate in time \(O(1)\), to satisfy \thref{assumption:Elementary}.
            
            Then, only neighbours qubits can interact. Depending on how the qubits are ordered, like in a line or on a grid, their connectivity changes. To overcome this problem, we need to add SWAP gates whenever we desire to control a gate on several qubits. Since the number of SWAP gates is however in \(O(n)\), it does not change the overall complexity of \(\mathsf{C}^n-\mathbf{U}\). Hence, for simplicity and legibility, we decided not to include the SWAP gates in the circuit.
            
            Finally, it is not possible to add gates dynamically on the quantum circuit. For instance, it is not possible to perform a measurement and add a gate dynamically as a function of the result. More precisely, there is no possibility to act on any qubit inside once it has begun to run. As a recall, the no-deleting theorem states:
            
            \begin{theorem}[No-deleting theorem]
                There is no unitary \(\mathbf{U}\) that maps an arbitrary state \ket{\psi} to the state \ket{0}.
            \end{theorem}
            
            The no-deleting theorem holds whenever the operations that we consider are unitary, which is the case whenever no measurement is performed. Here, we claim that this theorem still holds even whenever a measurement is performed.
            
            One may think about performing a measurement applying \(\X\) gates accordingly. Even if we were able to perform such a task, the coherence of the qubits wouldn't be guaranteed anymore. Hence, one would have to recreate the state on which it performed the measurement, and to apply measuring gates. Plus, it would imply that these measuring gates give two times in a row the same result, which has a probability of failure (otherwise there would be no point in performing a measurement in first place).
            
            Other considerations are to be taken into account, like for instance the number of qubits available. Since there is no way to mitigate them, we discuss them in the conclusion.
    \section{A quantum recommendation system}
        \label{sec:QRS}
        In this section, we intend to describe what a recommendation system is and how the quantum algorithm of \citeauthor{QRS} solves it.
        \subsection{Principles of a recommendation system}
            Let us consider some platform with \(m\) different users and \(n\) different products. Each user has the possibility, once bought, to rate a product according to a binary marking scheme: either the user liked the product, or she did not. The goal of a recommendation system is to provide a user a recommendation from a list of already graded products. This list includes also products graded by other users.
            
            Hence, we can represent this as a matrix with \(m\) rows and \(n\) columns, where each row represents a user and each column a product. Each coefficient of the matrix is either 0 or 1, indicating whether the user liked the product. This matrix is called the preference matrix, and we only have access to a portion of it (otherwise the problem would be trivial).
            
            From this incomplete preference matrix, the recommendation system will compute an approximation of the true preference matrix and use it to make recommendation. Its goal is to discover somehow the relationships between users to discover how the fact that some user rated a product positively affects the probability that another user would do the same. For this reason, it is assumed that the preference matrix has a good approximation of rank \(k\). In real-world terms, it means that it makes the assumption that there are \(k\) typical different users. Two users belonging to the same class will most likely rate positively the same products.
            
            In classical approaches at that time, an SVD decomposition was performed on the reconstructed preference matrix. The, by keeping only the \(k\) largest singular values, a rank-\(k\) matrix was obtained and used for making predictions. This approach is polynomial in the parameters of the preference matrix \(m\) and \(n\). The problem is that the reconstructed matrix has to be recomputed each time a user rates a new product. The problem is that the rank-\(k\) matrix had to be computed before getting a result from it. The principle of the algorithm of \citeauthor{QRS} is therefore to sample from this reconstructed matrix to get a recommendation once in polylogarithmic time.
        \subsection{A quantum algorithm as a recommendation system}
            The following describes the algorithm presented in \cite{QRS}. This section intends to give a high-level overview of this algorithm. Its actual implementation is discussed in \autoref{sec:QCircuit}. Let \(\mathbf{P}\in\{0\,;\,1\}^{m\times n}\) a matrix that has a good rank-\(k\) approximation. That is, for a given approximation parameter \(\varepsilon\):
            
            \[\exists\hat{\mathbf{P}},\left\|\mathbf{P} - \mathbf{P}_k\right\|_F\leqslant\varepsilon\|\mathbf{P}\|_F\]
            
            where \(\mathbf{P}_k\) is the matrix obtained by keeping only the \(k\) largest singular values in the SVD decomposition of \(\mathbf{P}\).
            
            Let \(\eta\in\mathbf{R}_+^*\). Then we define the matrix \(\hat{\mathbf{P}}\) as:
            
            \[\forall(i, j)\in\llbracket1\,;\,m\rrbracket\times\llbracket1\,;\,n\rrbracket,\hat{\mathbf{P}}_i,j\overset{\text{\tiny{def}}}{=}\begin{cases}\mathbf{P}_i,j\,\frac{\eta\,\|\mathbf{P}\|_F}{16\,n}&\text{with probability } \frac{16\,n}{\eta\,\|\mathbf{P}\|_F}\\0&\text{with probability } 1-\frac{16\,n}{\left(\eta\,\|\mathbf{P}\|_F\right)^2}\end{cases}\,.\]
            
            Once \(\hat{\mathbf{P}}\) has been built, the algorithm adds every new information it gets after every products it recommends, to it. Hence, the definition above is only used to initialize \(\hat{\mathbf{P}}\).
            
            Let \(j\) be the index of the row we want to sample. That is, we want a recommendation for user \(j\). Then the algorithm operates in several steps, which we describe in the following.
            
            \subsubsection{Loading the row vector as a quantum state}
                \label{subsubsec:Loading}
                The first thing to do is to load a quantum state that corresponds to \(\hat{\mathbf{P}}_j\). That is, we want to create:
                
                \[\ket{\hat{\mathbf{P}}_j} \overset{\text{\tiny{def}}}{=} \sum_{i=0}^{\lceil\log(n)\rceil-1}\hat{\mathbf{P}}_{j,i + 1}\,\ket{i}\,.\]
                
                The problem is hence to load in logarithmic time a quantum state corresponding to a vector stored in a classical data structure. This is done via the use of QRAM, as described in \autoref{subsec:LoadingQRAM}.
                
                We denote the SVD decomposition of \(\hat{\mathbf{P}}\) as:
                
                \[\hat{\mathbf{P}} = \sum_{i}\sigma_i\,\mathbf{u}_i\,\mathbf{v}_i^\dagger\,.\]
                
                Even though we load \ket{\hat{\mathbf{P}}_i} using its coefficients in the computational basis, we denote the quantum state in the left orthonormal basis in the SVD decomposition of \(\hat{\mathbf{P}}\), that is:
                
                \[\ket{\hat{\mathbf{P}}_i} \overset{\text{\tiny{def}}}{=} \sum_{i}\alpha_i\,\ket{v_i}\,.\]
                
            \subsubsection{Finding singular values}
                We now have the quantum state:
                
                \[\sum_{i}\alpha_i\,\ket{v_i}\]
                
                and we would like to find its singular values to get the state:
                
                \[\sum_{i}\alpha_i\,\ket{v_i}\,\ket{\sigma_i}\,.\]
                
                However, the Quantum Phase Estimation algorithm cannot be used right away, since \(\hat{\mathbf{P}}\) is not unitary.
                
                Hence, the goal is to define in logarithmic time a unitary \(\mathbf{W}\) whose eigenvalues are the singular values of \(\hat{\mathbf{P}}\). In order to define it, two matrices \(\mathbf{M}_1\in\mathbf{R}^{m\,n\times m}\) and \(\mathbf{M}_2\in\mathbf{R}^{m\,n\times n}\) are defined as follows:
                
                \[\forall i\in\llbracket1\,;\,m\rrbracket,\mathbf{M}_{1_i}\overset{\text{\tiny{def}}}{=}\mathbf{e}_i\otimes\frac{\hat{\mathbf{P}}_i}{\left\|\hat{\mathbf{P}}_i\right\|}\]
                
                with \(\mathbf{e}_i\) being the \(i\)\textsuperscript{th} vector of the computational basis of \(\mathbf{R}^{m}\) and:
                
                \[\forall i\in\llbracket1\,;\,n\rrbracket,\mathbf{M}_{2_i}\overset{\text{\tiny{def}}}{=}\frac{\overset{\sim}{\mathbf{P}}}{\left\|\hat{\mathbf{P}}\right\|_F}\otimes\mathrm{e}'_i\]
                
                with \(\mathbf{e}'_i\) being the \(i\)\textsuperscript{th} vector of the computational basis of \(\mathbf{R}^{n}\) and \(\overset{\sim}{\mathbf{P}}\) being defined as:
                
                \[\forall i\in\llbracket1\,;\,m\rrbracket,\overset{\sim}{\mathbf{P}}_i\overset{\text{\tiny{def}}}{=}\left\|\hat{\mathbf{P}}_i\right\|\,.\]
                
                Then, by naming \(\mathbf{U}\) the reflection on the vector space spanned by the columns of \(\mathbf{M}_1\) and \(\mathbf{V}\) the reflection on the vector space spanned by the columns of \(\mathbf{M}_2\), then the unitary \(\mathbf{W} = \mathbf{U}\,\mathbf{V}\) has as eigenvalues the singular values of \(\hat{\mathbf{P}}_i\).
                
                Hence, the task is to implement in logarithmic time \(\mathbf{W}\) and to apply the Quantum Phase Estimation algorithm on it to get the state:
                
                \[\sum_{i}\alpha_i\,\ket{v_i}\,\ket{\sigma_i}\,.\]
                
                which is discussed in \autoref{subsec:ImplementingQPE}.
            \subsubsection{Applying a gate according to a threshold}
                The previous part of the algorithm left us with the state:
                
                \[\sum_{i}\alpha_i\,\ket{v_i}\,\ket{\sigma_i}\,.\]
                
                In order to do a projection, we want to filter what singular values we want to keep. Hence, we define a threshold \(\tau\) and want to get the state:
                
                \[\sum_{i\in\mathcal{S}}\alpha_i\,\ket{v_i}\,\ket{\sigma_i}\,\ket{0} + \sum_{i\in\overline{\mathcal{S}}}\alpha_i\,\ket{v_i}\,\ket{\sigma_i}\,\ket{1}\]
                
                where \(\mathcal{S}\) is the set of indexes such that the corresponding eigenvector is associated with a eigenvalue \(\sigma_i\geqslant\tau\). In the algorithm of \citeauthor{QRS}, \(\tau\) is defined to be \(\sigma\,\left(1-\frac\kappa2\right)\).
                
                Hence, the goal now is to define a unitary \(\mathbf{T}_\sigma\) such that:
                
                \[\mathbf{T}_\sigma:\ket{t}\,\ket{0}\mapsto\begin{cases}\ket{t}\,\ket{1} &\text{if } t < \sigma\,\left(1-\frac\kappa2\right)\\\ket{t}\,\ket{0}&\text{otherwise}\end{cases}\,.\]
                
                Hence, we need to be able to compare two quantum states. This is discussed in \autoref{subsec:Threshold}.
                
                After having applied \(\mathrm{T}_\sigma\), we are left with the state:
                
                \[\sum_{i\in\mathcal{S}}\alpha_i\,\ket{v_i}\,\ket{\sigma_i}\,\ket{0} + \sum_{i\in\overline{\mathcal{S}}}\alpha_i\,\ket{v_i}\,\ket{\sigma_i}\,\ket{1}\]
                
                with \(\mathcal{S}\) being defined as above.
            \subsubsection{Concluding}
                Once the previous state obtained, we first need to uncompute the output of the Quantum Phase Estimation algorithm, so that the final state is not entangled. Hence, we are left with:
                
                \[\sum_{i\in\mathcal{S}}\alpha_i\,\ket{v_i}\,\ket{0} + \sum_{i\in\overline{\mathcal{S}}}\alpha_i\,\ket{v_i}\,\ket{1}\,.\]
                
                We then measure the second register in the computational basis. If the outcome is \ket{1}, then we redo everything. If it is \ket{0}, then we measure the first register in the computational basis to get a product for user \(j\).
                
    \section{Designing a quantum circuit for a recommendation system}
        \label{sec:QCircuit}
        We now design a quantum circuit to perform the algorithm of \citeauthor{QRS}. Let \(\mathbf{P}\) be the black box preference matrix. As a recall, we define \(\hat{\mathbf{P}}\) as:
        
        \[\forall(i, j)\in\llbracket1\,;\,m\rrbracket\times\llbracket1\,;\,n\rrbracket,\hat{\mathbf{P}}_i,j\overset{\text{\tiny{def}}}{=}\begin{cases}\mathbf{P}_i,j\,\frac{\eta\,\|\mathbf{P}\|_F}{16\,n}&\text{with probability } \frac{16\,n}{\eta\,\|\mathbf{P}\|_F}\\0&\text{with probability } 1-\frac{16\,n}{\left(\eta\,\|\mathbf{P}\|_F\right)^2}\end{cases}\,.\]
        
        \(\hat{\mathbf{P}}\) is assumed to be known at the beginning of the algorithm. It is also assumed that, by denoting \(\mathbf{P}_k\) the matrix obtained by keeping only the \(k\) largest singular values in the SVD decomposition of \(\mathbf{P}\):
        
        \[\left\|\mathbf{P}-\mathbf{P}_k\right\|_F\leqslant\varepsilon\,\|\mathbf{P}\|_F\]
        
        for a small rank \(k\) (generally lower than 100) and an approximation parameter \(\varepsilon\), both known beforehand. We also consider an index \(j\) to get a recommendation from.
        
        As explained in \autoref{subsubsec:Loading}, the very first step is to load in logarithmic time the state:
        
        \[\ket{\hat{\mathbf{P}}_j} \overset{\text{\tiny{def}}}{=} \sum_{i=0}^{\lceil\log(n)\rceil-1}\hat{\mathbf{P}}_{j,i + 1}\,\ket{i}\,.\]
        
        \subsection{Loading from QRAM}
            \label{subsec:LoadingQRAM}
            In order to load a quantum state from a real vector, \citeauthor{QRS} make use of Quantum RAM, also denoted QRAM. The principle is to have a classical data structure with quantum access, that is, a data structure from which we can get information by querying it with a quantum state, potentially in superposition.
            
            While some general-purpose QRAM circuit has been stud, for instance in \cite{QRAMCircuit}, we will describe a design specially designed for state creation, described by \citeauthor{Prakash} in \cite{Prakash}.
            
            \subsubsection{Designing Quantum RAM}
                \label{subsubsec:QRAM}
                Let \(\mathbf{x}\in\mathbf{R}^p\) be a real vector. The QRAM structure is a binary tree with \(2^{\left\lceil\log_2(p)\right\rceil}\) leaves with the following properties:
                
                \begin{enumerate}
                    \item The leaf number \(i\) stores the value \(x_i^2\), along with the sign of \(x_i\). Potential additional leaves stores the value \(0\). 
                    \item Each node stores the sum of the values of its two children.
                \end{enumerate}
                
                Hence, the root stores \(\sum_ix_i^2=\|\mathbf{x}\|^2\). For instance, with:
                
                \[\mathbf{x}=\begin{pmatrix}0.2\\-0.15\\0.1\\ -0.1\\0\\0.3\end{pmatrix}\]
                
                the QRAM tree would be:
                
                \begin{figure}[ht]
                    \centering
                    \begin{forest}
                        for tree={circle,draw, minimum size=1.5cm, inner sep=1pt, l sep=1.5cm}
                        [0.1725 
                            [0.0825, edge label={node[midway, fill=white] {0}}
                                [0.0625, edge label={node[midway, fill=white] {00}}
                                    [{$0.04, +$}, edge label={node[midway, fill=white] {000}}]
                                    [{$0.0225, -$}, edge label={node[midway, fill=white] {001}}]
                                ]
                                [0.02, edge label={node[midway, fill=white] {01}}
                                    [{$0.01, +$}, edge label={node[midway, fill=white] {010}}]
                                    [{$0.01, -$}, edge label={node[midway, fill=white] {011}}]
                                ]
                            ]
                            [0.09, edge label={node[midway, fill=white] {1}}
                                [0.09, edge label={node[midway, fill=white] {10}}
                                    [{$0, +$}, edge label={node[midway, fill=white] {100}}]
                                    [${0.09, +}$, edge label={node[midway, fill=white] {101}}]
                                ]
                                [0, edge label={node[midway, fill=white] {11}}
                                    [{$0, +$}, edge label={node[midway, fill=white] {110}}]
                                    [{$0, +$}, edge label={node[midway, fill=white] {111}}]
                                ]
                            ] 
                        ]
                        \end{forest}
                    \caption{An example of a QRAM tree}
                \end{figure}
                
                We now define the gate \(\mathbf{L}_\mathrm{x}\) with the following property:
                
                \[\mathbf{L}_\mathrm{x}\,\ket{0}^{\otimes\left\lceil\log_2(p)\right\rceil}=\ket{x}\,.\]
                
                Hence, our goal is to decompose \(\mathbf{L}_\mathrm{x}\) into elementary gates to ensure that it can be implemented in logarithmic time. In order to do so, we use the algorithm presented in \cite{QLSPrimer}.
                
                \begin{algorithm}[H]
                    \SetAlgoLined
                    \DontPrintSemicolon
                    \SetKwInOut{Input}{Input}
                    \SetKwInOut{Output}{Output}
                    \SetKwFunction{ProcessNode}{processNode}
                    \SetKwProg{Fn}{function}{:}{}
                    
                    \Input{A vector \(\mathbf{x}\in\mathbf{R}^p\) stored in QRAM, a quantum state \(\ket{q_1\,q_2\,\cdots\,q_{\left\lceil\log_2(p)\right\rceil}}=\ket{0}^{\otimes\left\lceil\log_2(p)\right\rceil}\).}
                    \Output{The quantum state \(\ket{q_1\,q_2\,\cdots\,q_{\left\lceil\log_2(p)\right\rceil}}=\ket{x}\).}
                    
                    \Fn{\ProcessNode{Node \(u\)}}{
                        Let \(u_l\) be the left child of \(u\), \(u_r\) be its right child and let \(k\) be the level of the tree at which \(u\) is. For instance, the level of the root is 1, while the level of a leaf is \(\left\lceil\log_2(p)\right\rceil\). Note that we can access the values of these nodes  in time \(O(k)\) thanks to the binary tree structure. Compute \(\theta\) being defined as:
                        
                        \[\theta\overset{\text{\tiny{def}}}{=}\arccos\left(\sqrt{\frac{\valueMath(u_l)}{\valueMath(u)}}\right)\,.\]
                        
                        Apply on \(\ket{q_k}\) the gate \(\mathbf{R}_y(2\,\theta)\) controlled by \ket{q_1\,\cdots\,q_{k-1}} being equal to the binary expansion of \(u\).
                        
                        \uIf{\(u_l\) is a leaf} {
                            \uIf{\(\sgn\left(u_l\right)=+\) and \(\sgn\left(u_r\right)=-\)} {
                                Apply \(\mathbf{R}_z(\pi)\) controlled on \ket{q_1\,\cdots\,q_{k-1}} as previously on \ket{q_k}.
                            }
                            \uElseIf{\(\sgn\left(u_l\right)=-\) and \(\sgn\left(u_r\right)=+\)} {
                                Apply \(\mathbf{R}_y(2\,\pi)\,\mathbf{R}_z(\pi)\) controlled on \ket{q_1\,\cdots\,q_{k-1}} as previously on \ket{q_k}.
                            }
                            \uElseIf{\(\sgn\left(u_l\right)=-\) and \(\sgn\left(u_r\right)=-\)} {
                                Apply \(\mathbf{R}_y(2\,\pi)\) controlled on \ket{q_1\,\cdots\,q_{k-1}} as previously on \ket{q_k}.
                            }
                        }
                        
                        \Else{
                            \ProcessNode{\(u_l\)} \;
                            \ProcessNode{\(u_r\)} \;
                        }                        
                    }\;
                    Apply \ProcessNode on the root of the QRAM tree.
                    
                    \caption{Loading a vector from QRAM \cite{QLSPrimer}}
                \end{algorithm}
                
                The correctness of this algorithm is proved in \cite{QLSPrimer}. Taking back our previous example, this algorithm will generate the following circuit:
                
                \begin{figure}[ht]
                    \centering
                    \begin{quantikz}
                        \lstick{\ket{q_1}} & \gate{\mathbf{R}_y\left(2\,\theta_{\text{root}}\right)} & \octrl{1} & \octrl{1} & \octrl{1} & \octrl{1} & \octrl{1} & \qw & \cdots\\
                        \lstick{\ket{q_2}} & \qw & \gate{\mathbf{R}_y\left(2\,\theta_{0}\right)} & \octrl{1} & \octrl{1} & \ctrl{1} & \ctrl{1} & \qw & \cdots\\
                        \lstick{\ket{q_3}} & \qw & \qw & \gate{\mathbf{R}_y\left(2\,\theta_{00}\right)} & \gate{\mathbf{R}_z(\pi)} & \gate{\mathbf{R}_y\left(2\,\theta_{01}\right)} & \gate{\mathbf{R}_z(\pi)} & \qw & \cdots
                    \end{quantikz}
                    \caption{An example of a circuit generated by the loading from QRAM algorithm}
                \end{figure}
                
                Several things are to be noted with this implementation:
                
                \begin{itemize}
                    \item The algorithm can be slightly improved by not applying gates for nodes whose value is equal to their left children's.
                    \item The computation of \(\theta_{11}\) implies a division by zero. Since this can only happen when a leaf and its parent share the same value, the previous point would apply.
                    \item Qubit \ket{q_k} undergoes \(2^k\) rotations. More are actually applied on the last one, with a limit of \(3\times2^{\left\lceil\log_2(p)\right\rceil}\). Hence, the total number of consecutive gates applied with this algorithm is:
                    
                    \[3\times2^{\left\lceil\log_2(p)\right\rceil} + \sum_{k=1}^{\left\lceil\log_2(p)\right\rceil - 1}2^k=2^{2+\left\lceil\log_2(p)\right\rceil} - 1\]
                    
                    which makes this algorithm linear in \(p\), while we want to have a logarithmic complexity.
                \end{itemize}
            \subsubsection{Parallel execution of rotations}
                The thing is that we can parallelize the rotations applied. Since our goal is to get data from the QRAM from a superposed state, let us define a function \(f\) such that:
                
                \[f:\left|\begin{array}{lcl}\mathbf{R}^p&\to&\mathbf{R}^t\\\mathbf{x}&\mapsto&\theta_{\mathbf{x}}\end{array}\right.\,.\]
                
                The goal of \(f\) is to take a vector from the computational basis of \(\mathbf{R}^p\) and to map it to the corresponding rotation angle to be performed at a certain level. Hence, the associated matrix of \(f\) is a permutation matrix.
                
                Using \(\mathbf{U}_f\), we can now have access to \ket{\theta_x}. As a recall, since we assume \(f\) is efficiently computable classically, so is \(\mathbf{U}_f\). We now want to perform a rotation around the $y$-axis of angle $2\,\theta_x$.
                
                In order to give the intuition on the way to perform this, let us consider the following circuit:
                
                \begin{figure}[ht]
                    \centering
                    \begin{quantikz}
                        \lstick{\ket{x}} & \qw & \qw\\
                        \lstick{\ket{\theta_1}} & \gate{\mathbf{R}_z(1)} & \qw\\
                        \lstick{\ket{\theta_2}} & \gate{\mathbf{R}_z\left(\frac12\right)} & \qw\\
                        \lstick{\ket{\theta_2}} & \gate{\mathbf{R}_z\left(\frac14\right)} & \qw
                    \end{quantikz}
                    \caption{A rotation around the $z$-axis using a quantum state}
                \end{figure}
                
                The final quantum state is given by:
                
                \[\ket{x}\otimes\mathrm{e}^{\mathrm{i}\,\theta_1}\,\ket{\theta_1}\otimes\mathrm{e}^{\mathrm{i}\,\theta_2\,2^{-1}}\,\ket{\theta_2}\otimes\mathrm{e}^{\mathrm{i}\,\theta_3\,2^{-2}}\ket{\theta_3}=\mathrm{e}^{\mathrm{i}\,\theta}\,\ket{x}\,\ket{\theta}\,.\]
                
                Hence, we are able using this to perform a rotation around the \(z\)-axis from a quantum state. Quite similarly to what happened in the previous circuit, we will now apply phase gates on the \ket{\theta_k} qubits, but this time controlled on the target qubit. The reason why we perform this will appear in the state description. Let us consider the following circuit, where we only took two qubits for approximating \(\theta\) for legibility:
                
                \begin{figure}[ht]
                    \centering
                    \begin{quantikz}
                     \lstick{\ket{q_1}} & \gate{\mathbf{R}_y(2\,\theta_{\text{root}})} & \qw\slice{\ket{\varphi_0}} & \qw & \gate[wires=3]{\mathbf{U}_f} & \qw\slice{\ket{\varphi_1}} & \qw & \qw & \qw\slice{\ket{\varphi_2}} & \qw & \qw & \qw\slice{\ket{\varphi_3}} & \qw & \gate[wires=3]{\mathbf{U}_f^\dagger} & \qw\slice{\ket{\varphi_3}} & \qw\\
                     \lstick{\ket{0}} & \qw & \qw & \qw & & \qw & \qw & \gate{\mathbf{R}_z(1)} & \qw & \qw & \qw & \qw & \qw & & \qw & \qw\\
                     \lstick{\ket{0}} & \qw & \qw & \qw & & \qw & \qw & \qw & \qw & \qw & \gate{\mathbf{R}_z\left(\frac12\right)} & \qw & \qw & & \qw & \qw\\
                     \lstick{\ket{q_2}} & \qw & \qw & \qw & \qw & \qw & \qw & \octrl{-2} & \qw & \qw & \octrl{-1} & \qw & \qw & \qw & \qw & \qw
                    \end{quantikz}
                    \caption{Rotating around the $z$-axis using parallel computation}
                \end{figure}

                In order to see that this circuit almost performs the operation we want, let us describe the quantum state at every step. First of all, we have:
                
                \[\ket{\varphi_0}=(\alpha\,\ket{000} + \beta\,\ket{100})\,(\gamma\,\ket{0} + \delta\,\ket{1})\,.\]
                
                We then apply the \(\mathbf{U}_f\) gate on the first three qubits. As a recall, since \(\mathbf{U}_f\) implements \(f\), this will leave the first qubit unchanged, while it will modify the two others qubits to the actual value of \(\theta_x\). Hence, we got the state:
                
                \[\ket{\varphi_1} = \left(\alpha\,\ket{0\theta_{0,0}\theta_{0,1}} + \beta\,\ket{1\theta{1,0}\theta{1,1}}\right)\,(\gamma\,\ket{0} + \delta\,\ket{1})\,.\]
                
                Note that we denoted \(\theta_{x, n}\) as the \(n+1\)\textsuperscript{th} qubit of \(\theta_x\). It will be easier for the following to develop this expression:
                
                \[\ket{\varphi_1} = \alpha\,\gamma\,\ket{0\theta_{0,0}\theta_{0,1}0} + \alpha\,\delta\,\ket{0\theta_{0,0}\theta_{0,1}1} + \beta\,\gamma\,\ket{1\theta_{1,0}\theta_{1,1}0} + \beta\,\delta\,\ket{1\theta_{1,0}\theta_{1,1}1}\,.\]
                
                We now apply the \(\mathbf{R}_z(1)\) gate controlled on the last qubit:
                
                \[\ket{\varphi_2} = \alpha\,\gamma\,\ket{0\theta_{0,0}\theta_{0,1}0} + \alpha\,\delta\,\mathrm{e}^{\mathrm{i}\,\theta_{0,0}}\,\ket{0\theta_{0,0}\theta_{0,1}1} + \beta\,\gamma\,\ket{1\theta_{1,0}\theta_{1,1}0} + \beta\,\delta\,\mathrm{e}^{\mathrm{i}\,\theta_{1,0}}\,\ket{1\theta_{1,0}\theta_{1,1}1}\,.\]
                
                Similarly, we apply the \(\mathbf{R}_z\left(\frac12\right)\) gate on the third qubit controlled on the last qubit:
                
                \[\ket{\varphi_3} = \alpha\,\gamma\,\ket{0\theta_{0,0}\theta_{0,1}0} + \alpha\,\delta\,\mathrm{e}^{\mathrm{i}\,\theta_{0}}\,\ket{0\theta_{0,0}\theta_{0,1}1} + \beta\,\gamma\,\ket{1\theta_{1,0}\theta_{1,1}0} + \beta\,\delta\,\mathrm{e}^{\mathrm{i}\,\theta_{1}}\,\ket{1\theta_{1,0}\theta_{1,1}1}\,.\]
                
                Finally, we uncompute the first three qubits to be left with:
                
                \[\ket{\varphi_4} = \alpha\,\gamma\,\ket{000} + \alpha\,\delta\,\mathrm{e}^{\mathrm{i}\,\theta_{0}}\,\ket{0001} + \beta\,\gamma\,\ket{1000} + \beta\,\delta\,\mathrm{e}^{\mathrm{i}\,\theta_{1}}\,\ket{1001}\,.\]
                
                Which we can rewrite as:
                
                \[\ket{\varphi_4} = (\alpha\,\ket{000} + \beta\,\ket{001})\,\gamma\,\ket{0} + \left(\alpha\,\mathrm{e}^{\mathrm{i}\,\theta_0}\,\ket{000}+\beta\,\mathrm{e}^{\mathrm{i}\,\theta_1}\,\ket{100}\right)\,\delta\,\ket{1}\]
                
                which is exactly what we wanted to get. Indeed, we left the three first qubits unchanged, and applied rotations around the \(z\)-axis on the last qubit according to the state \ket{x}. The only thing left to do now is to convert rotations around the \(z\)-axis to rotations around the \(y\)-axis. In order to do this, we want to apply basis change matrices before and after having applied rotations around the \(z\)-axis. Let us show that the gate \(\frac{1}{\sqrt{2}}\,\left(\mathrm{e}^{\mathrm{i}\,\frac\pi2}\,\mathbf{R}_y(\pi)+\mathbf{R}_z(\pi)\right)\) is the gate we are looking for. Indeed, we have:
                
                \begin{align*}
                    \frac{1}{\sqrt{2}}\begin{pmatrix}1&-\mathrm{i}\\\mathrm{i} & -1\end{pmatrix}\,\begin{pmatrix}1&0\\0&\mathrm{e}^{\mathrm{i}\,\varphi}\end{pmatrix}\,\left(\frac{1}{\sqrt{2}}\begin{pmatrix}1&-\mathrm{i}\\\mathrm{i} & -1\end{pmatrix}\right)^{-1} &= \frac12\begin{pmatrix}1&-\mathrm{i}\\\mathrm{i} & -1\end{pmatrix}\,\begin{pmatrix}1&0\\0&\mathrm{e}^{\mathrm{i}\,\varphi}\end{pmatrix}\,\begin{pmatrix}1&-\mathrm{i}\\\mathrm{i} & -1\end{pmatrix}\\
                    &= \frac12\,\begin{pmatrix}1&-\mathrm{i}\,\mathrm{e}^{\mathrm{i}\,\varphi}\\\mathrm{i} & -\mathrm{e}^{\mathrm{i}\,\varphi}\end{pmatrix}\,\begin{pmatrix}1&-\mathrm{i}\\\mathrm{i} & -1\end{pmatrix}\\
                    &= \frac12\,\begin{pmatrix}1+\mathrm{e}^{\mathrm{i}\,\varphi} & -\mathrm{i}\,\left(1-\mathrm{e}^{\mathrm{i}\,\varphi}\right)\\\mathrm{i}\,\left(1-\mathrm{e}^{\mathrm{i}\,\varphi}\right) & 1 + \mathrm{e}^{\mathrm{i}\,\varphi}\end{pmatrix}\\
                    &= \frac12\,\begin{pmatrix}2\,\cos\left(\frac\varphi2\right)\,\mathrm{e}^{\mathrm{i}\,\frac\varphi2} & -2\,\sin\left(\frac\varphi2\right)\,\mathrm{e}^{\mathrm{i}\,\frac\varphi2}\\2\,\sin\left(\frac\varphi2\right)\,\mathrm{e}^{\mathrm{i}\,\frac\varphi2}&2\,\cos\left(\frac\varphi2\right)\,\mathrm{e}^{\mathrm{i}\,\frac\varphi2}\end{pmatrix}\\
                    &= \mathrm{e}^{\mathrm{i}\,\frac\varphi2}\,\mathbf{R}_y(\varphi)
                \end{align*}
                
                Hence, up to a global phase which is irrelevant, we can using these basis change matrices use rotations around the \(z\)-axis to perform rotations around the \(y\)-axis. Hence, the final circuit to perform such a task is as follows:
                
                \begin{figure}[ht]
                    \centering
                    \begin{quantikz}
                        \lstick{\ket{q_1}} & \gate{\mathbf{R}_y\left(\theta_{\text{root}}\right)} & \gate[wires=3]{\mathbf{U}_f} & \qw & \qw & \gate[wires=3]{\mathbf{U}_f^\dagger} & \qw\\
                        \lstick{\ket{0}} & \qw & & \gate{\mathbf{R}_z(1)} & \qw & & \qw\\
                        \lstick{\ket{0}} & \qw & & \qw & \gate{\mathbf{R}_z\left(\frac12\right)} & & \qw\\
                        \lstick{\ket{q_2}} & \qw & \gate{\frac{1}{\sqrt{2}}\,\left(\mathrm{e}^{\mathrm{i}\,\frac\pi2}\,\mathbf{R}_y(\pi)+\mathbf{R}_z(\pi)\right)} & \ctrl{-2} & \ctrl{-1} & \gate{\frac{1}{\sqrt{2}}\,\left(\mathrm{e}^{\mathrm{i}\,\frac\pi2}\,\mathbf{R}_y(\pi)+\mathbf{R}_z(\pi)\right)} & \qw
                    \end{quantikz}
                    \caption{Circuit to perform rotations around the \(y\)-axis efficiently}
                \end{figure}
                
                This circuit can be generalised for an arbitrary number of qubits for approximating \(\theta\) and for any level of the tree \(k\).
                                
                We now have defined the loading gate \(\mathbf{L}_\mathrm{x}\), which we can apply to get the state \(\ket{x}=\ket{\hat{\mathrm{P}}_j}\).


        \subsection{Applying the Quantum Phase Estimation algorithm}
            \label{subsec:ImplementingQPE}
            Now that the state \ket{\hat{\mathrm{P}}_j} has been loaded from QRAM, we are to append a quantum register of size \(\lceil\log(n)\rceil\) before the quantum register in which \ket{\hat{\mathrm{P}}_j} has been loaded and to apply a unitary \(\mathbf{Q}\) to get the state:
            
            \[\ket{\mathbf{Q}\,\hat{\mathbf{P}}_j}=\sum_i\alpha_i\,\ket{\overset{\sim}{\mathbf{A}}, j}\,.\]
            
            Since \(\overset{\sim}{\mathbf{P}}\) is easily loadable via QRAM, we only have to apply the loading gate \(\mathbf{L}_{\overset{\sim}{\mathbf{P}}}\) to the first register to get the desired state. As a recall, \(\overset{\sim}{\mathbf{P}}\) is defined as:
            
            \[\forall i\in\llbracket1\,;\,m\rrbracket,\overset{\sim}{\mathbf{P}}_i=\|\hat{\mathbf{P}}_i\|\,.\]
            
            Let us assume that \(\hat{\mathbf{P}}\) is stored in QRAM. Storing a matrix in QRAM is done similarly to storing a vector in QRAM: a binary tree is built just like the row vectors of \(\hat{\mathbf{P}}\) were real numbers, then each leaf is the root of a QRAM tree that stores the corresponding vector.
            
            Two cases are now possible: either the structure we possess has a quantum access, or not. Since we did not manage to code such a structure, our code does not match the original algorithm's complexity. Indeed, the goal is now to define a unitary \(\overset{\sim}{\mathbf{U}}\) such that:
            
            \[\overset{\sim}{\mathbf{U}}\,\ket{i}\,\ket{0}^{\otimes\left\lceil\log_2(n)\right\rceil}=\ket{i}\,\ket{\hat{\mathbf{P}}_i}\,.\]
            
            In the case where the data structure lacks a quantum access, the way to implement it is to use \(m\) different loading gates, which leads to a time complexity for this gate of \(O(m\,\log(n))\). If the data structure has a quantum access, then by definition it will implement \(\overset{\sim}{\mathbf{U}}\).
            
            The other unitary that we need, called \(\overset{\sim}{\mathbf{V}}\) in the original algorithm, is simply the \(\mathbf{L}_{\overset{\sim}{\mathbf{P}}}\) gate we used before.
            
            Assuming that the data structure we are using has a quantum access, both \(\overset{\sim}{\mathbf{U}}\) and \(\overset{\sim}{\mathbf{V}}\) can be implemented in time \(\polylog(m\,n)\).
            
            The Quantum Recommendation System algorithm uses two unitary matrices \(\mathbf{U}\) and \(\mathbf{V}\) to perform the Quantum Phase Estimation algorithm. Both these gates are reflections on certain vector fields and both can be defined using \(\overset{\sim}{\mathbf{U}}\) and \(\overset{\sim}{\mathbf{V}}\):
            
            \[\mathbf{U}=\overset{\sim}{\mathbf{U}}\,\mathbf{R}_1\,\left(\overset{\sim}{\mathbf{U}}\right)^{-1}\]
            
            and:
            
            \[\mathbf{U}=\overset{\sim}{\mathbf{V}}\,\mathbf{R}_0\,\left(\overset{\sim}{\mathbf{V}}\right)^{-1}\]
            
            where \(\mathbf{R}_1\) is the reflection on the vector field \(\ket{y}\,\ket{0}^{\otimes\lceil\log(n)\rceil}\) for \(\ket{y}\in\mathbf{R}^m\) and where \(\mathbf{R}_0\) is the reflection on the vector field \(\ket{0}^{\otimes\lceil\log(m)\rceil}\,\ket{x}\) for \(\ket{x}\in\mathbf{R}^n\). It is easy to implement both \(\mathbf{R}_0\) and \(\mathbf{R}_1\) since they are both diagonal matrices with \(-1\) coefficients everywhere except on the vector they perform a reflection on. For instance, we have:
            
            \[\mathbf{R}_0=\begin{pmatrix}\mathbf{I}_{n} & \mathbf{0}\\\mathbf{0} & -\mathbf{I}_{m\,n - n}\end{pmatrix}\,.\]
            
            \(-\mathbf{I}_{m\,n-n}\) can be implemented using a tensor product of \(O(\log(m\,n))\) \(\mathbf{R}_y(2\,\pi)\) gates. Hence, we can implement \(\mathbf{R}_0\) as a single gate \(-\mathbf{I}_{m\,n-n}\) that acts on the second register and controlled by the first register being in state \(\ket{0}^{\otimes\lceil\log(n)\rceil}\). Each of these controlled gates will be implemented in time \(O(\log(n))\) because of the numerous control qubits. As a consequence, \(\mathbf{R}_0\) can be implemented in time \(O(\polylog(m\,n))\), which matches the complexity of the original algorithm. A similar reasoning holds for \(\mathbf{R}_1\).
            
            Hence, we are able to implement \(\mathbf{U}\,\mathbf{V}\) in polylogarithmic time. We can finally apply the Quantum Phase Estimation algorithm using this unitary. However, it is not possible to do it as originally claimed by \citeauthor{QRS}. Indeed, as mentioned in \autoref{subsec:Hardware}, it is not possible to measure a state and then to apply \(\X\) gates accordingly to uncompute it. Hence, it is not possible to increase the probability of success of the Quantum Phase Estimation algorithm using this way.
            
            However, it is stated in \cite{QCAQI}, that one can increase the number of qubits used in order to increase the probability of success of the algorithm. Indeed, if we want the algorithm to output a \(n\)-bit approximation of the phase of an eigenvalue, one can use instead \(n+p\) qubits. \citeauthor{QCAQI} show then that the probability of success, that is the probability to obtain the desired state in the first \(n\) qubits, is at least \(1-\frac{1}{2\,\left(2^p-2\right)}\).
            
            Our main objective is to match the original complexity of the algorithm. Since we cannot repeat the QPE \(\log(n)\) times as wanted by the original algorithm, we are allowed to add \(p\) qubits, with \(p\) verifying:
            
            \[2^p=\log(n)\,.\]
            
            Indeed, adding \(p\) qubits multiply by \(2^p\,p^2\) the time taken by the algorithm. Neglecting \(p^2\) in comparison with \(2^p\), and because we consider complexities in \(\polylog(m\,n)\) anyway, we find that we can use an additional number of \(p=\left\lceil\log_2(\log(n))\right\rceil\) qubits. The probability of success is now at least \(1-\frac{1}{2\,\left(\log(n) - 2\right)}\), which is lower than the original probability of success given in \cite{QRS}.
            
            Still, it is necessary to mention that this cannot be implemented currently. Indeed, it is later needed in the algorithm to uncompute the output of the Quantum Phase Estimation algorithm, so that the state is not entangled. Yet, as long as we perform a measurement, which is necessary to get the approximation, we cannot uncompute this output. It is not possible either to run the Quantum Phase Estimation once to get the estimation, since the output of the Quantum Phase estimation is entangled with the rest of the qubits. In the following, we will assume that this problem has been tackled.
            
            The QPE is used to get an estimation of the singular values of \(\hat{\mathbf{P}}\). However, what the QPE outputs is an estimation of the phase of the corresponding eigenvalue. In order not to have to create the state \ket{\sigma_i} obtained after the measurement (which would be entangled anyway), we keep this output from the Phase Estimation and work with it, rather than with \(\ket{\sigma_i}\). Hence, the state after having applied the QPE and having uncomputed \(\mathbf{Q}\) is:
            
            \[\sum_i\alpha_i\,\ket{v_i}\,\ket{a_i}\,.\]
        \subsection{Separating states according to a threshold}
            \label{subsec:Threshold}
            \subsubsection{Defining the condition}
                Once the QPE has been applied, the state of the system is \(\sum_i\alpha_i\,\ket{v_i}\,\ket{a_i}\), where \(\ket{a_i}\) is the output of the phase estimation algorithm associated to the eigenvector \(\ket{v_i}\) of \(\mathbf{U}\,\mathbf{V}\), that is:
                \[\forall i\in\llbracket1\,;\,\lceil\log(n)\rceil\rrbracket,\mathbf{U}\,\mathbf{V}\,\ket{v_i}\approx\mathrm{e}^{2\,\mathrm{i}\,\pi\,a_i}\,\ket{v_i}\,.\]
                
                What we want to do now is to define a threshold unitary \(\mathbf{T}_\sigma\) such that:
                
                \[\mathbf{T}_\sigma:\ket{t}\,\ket{0}\mapsto\begin{cases}\ket{t}\,\ket{1} &\text{if } t < \sigma\,\left(1-\frac\kappa2\right)\\\ket{t}\,\ket{0}&\text{otherwise}\end{cases}\,.\]
                
                In the original paper, \(\mathbf{T}_\sigma\) is applied on the second quantum register, which contains the approximation of the singular values of \(\mathbf{A}\). Hence, what we want to do is to design \(\mathbf{T}_\sigma\) so that it can be applied to the second register directly following the QPE. Let us consider an approximation \(\overline{\sigma_i}\) of a singular value \(\sigma_i\) of \(\mathbf{A}\). By definition:
                
                \[\exists\theta_i\in[-\pi\,;\,\pi[,\overline{\sigma_i}=\cos\left(\frac{\theta_i}{2}\right)\,\|\mathbf{A}\|_F\,.\]
                
                What we want to do now is to perform a mapping between \(a_i\) and \(\theta_i\), since we only have access to \(a_i\). As a recall, \(a_i\) is the output of the Quantum Phase Estimation algorithm. Hence, the phase of the eigenvalue is \(2\,\pi\,a_i\). The problem is that \(\theta_i\) is defined on \([-\pi\,;\,\pi[\). Hence, \(\theta_i\) and \(2\,\pi\,a_i\) corresponds to the same angle for \(a_i\in[0\,;\,\frac12[\). For \(a_i\geqslant\frac12\), \(\theta_i\) grows linearly again with \(a_i\), and we have:
                
                \[\exists(m,p)\in\mathbf{R}^2,\left\{\begin{array}{lcl}m\times\frac12+p &=& -\pi\\\\m\times1 + p &=& 0\end{array}\right.\]
                
                Hence, we have:
                
                \[\theta_i = \begin{cases}2\,\pi\,a_i&\text{if }a_i\in\left[0\,;\,\frac12\right[\\2\,\pi\,\left(a_i-1\right)&\text{if }a_i\in\left[\frac12\,;\,1\right[\end{cases}\,.\]
                
                Hence, the following holds:
                
                \begin{align*}
                    &\sigma_i < \sigma\,\left(1 - \frac\kappa2\right)\\
                    \iff&\cos\left(\frac{\theta_i}{2}\right) < \frac{\sigma\,\left(1 - \frac\kappa2\right)}{\|\mathbf{A}\|_F}\\
                    \iff&\exists k\in\mathbf{Z},\pm\frac{\theta_i}{2}\in\left]2\,k\,\pi + \arccos\left(\frac{\sigma\,\left(1 - \frac\kappa2\right)}{\|\mathbf{A}\|_F}\right)\,;\,2\,k\,\pi + \frac\pi2\right]\,.
                \end{align*}
                
                Since \(\frac{\theta_i}{2}\in\left[-\frac\pi2\,;\,\frac\pi2\right[\), this is equivalent to:
                
                \[\sigma_i < \sigma\,\left(1 - \frac\kappa2\right)\iff\left|\frac{\theta_i}{2}\right|\in\left]\arccos\left(\frac{\sigma\,\left(1 - \frac\kappa2\right)}{\|\mathbf{A}\|_F}\right)\,;\,\frac\pi2\right]\,.\]
                
                By replacing \(\theta_i\) by its definition, this gives us:
                
                \[\sigma_i < \sigma\,\left(1 - \frac\kappa2\right)\iff\begin{cases}a_i\in\left]\frac1\pi\,\arccos\left(\frac{\sigma\,\left(1 - \frac\kappa2\right)}{\|\mathbf{A}\|_F}\right)\,;\,\frac12\right]&\text{if }a_i<\frac12\\1-a_i\in\left]\frac1\pi\,\arccos\left(\frac{\sigma\,\left(1 - \frac\kappa2\right)}{\|\mathbf{A}\|_F}\right)\,;\,\frac12\right]&\text{if }a_i\geqslant\frac12\end{cases}\,.\]
                
                Which gives us our final criteria:
                
                \[\sigma_i < \sigma\,\left(1 - \frac\kappa2\right)\iff\begin{cases}\frac1\pi\,\arccos\left(\frac{\sigma\,\left(1 - \frac\kappa2\right)}{\|\mathbf{A}\|_F}\right) < a_i&\text{if }a_i<\frac12\\1-\frac1\pi\,\arccos\left(\frac{\sigma\,\left(1 - \frac\kappa2\right)}{\|\mathbf{A}\|_F}\right) > a_i&\text{if }a_i\geqslant\frac12\end{cases}\,.\]
            
            \subsubsection{Comparing a quantum state and a real number bitwise}
                Since we know \(\sigma\) and \(\kappa\) beforehand, and since \(\|\mathbf{A}\|_F\) is easily accessible, we can compute \(b_1=\frac1\pi\,\arccos\left(\frac{\sigma\,\left(1 - \frac\kappa2\right)}{\|\mathbf{A}\|_F}\right)\) and \(b_2 = 1 - b_1\). Let \(b\) represent either \(b_1\) or \(b_2\).
                
                What we want to do is to determine whether \(b<a_i\) by looking at their binary expansion. As a recall, the following holds:
                
                \[\forall N\in\mathbf{N},2^-N=\sum_{k=N+1}^{+\infty}2^{-k}\,.\]
                
                In particular:
                
                \[\forall N\in\mathbf{N},\forall M\geqslant N,\forall \lambda\in\{0\,;\,1\}^{M-N},2^{-N}>\sum_{k=N+1}^M\lambda_k\,2^{-k}\,.\]
                
                We also know that we can write \(a_i\) using its binary expansion:
                
                \[a_i=\sum_{k=1}^{\lceil\log(n)\rceil}a_{i,k}2^{-k}\]
                
                and the same holds for \(b\):
                
                \[b=\sum_{k=1}^{\lceil\log(n)\rceil}b_{k}2^{-k}\,.\]
                
                Using this, we know that the first bit \(j\) at which \(b_j\neq a_{i,j}\) determines whether \(a_i\geqslant b\). If \(a_{i,j}=1\), then \(a_i>b\). If \(b_j=1\), then \(b>a_i\).
                
                Note that since \(\frac{\sigma\,\left(1 - \frac\kappa2\right)}{\|\mathbf{A}\|_F}\in]0\,;\,1]\), we have \(b_1\in\left[0\,;\,\frac12\right[\), hence \(b_{1,1}=0\) and \(b_{1,2}=1\). Hence, the goal is now to compare \(b\) and \(a_i\) bitwise to determine which one is superior. We consider the state \(\ket{\overline{a_i}} = \ket{a_{i,2}\cdots a_{i,\lceil\log(n)\rceil}}\), which represents \(a_i\) if \(a_i<\frac12\), that is \(a_{i,1}=0\), and \(a_i-\frac12\) if \(a_i>\frac12\), that is \(a_{i, 1} = 1\). Hence, the algorithm will go through \(\lceil\log(n)\rceil - 1\) steps for each one of \(b_1\) and \(b_2\). Without loss of generality, we will for now consider the case \(a_i<\frac12\), that is \(b=b_1\). We identify each of the steps by the number of the bit it applies to. Hence, the first step is identified with \(2\) since there is no need to test the fist bit, the second one with \(3\) and the last one with \(\lceil\log(n)\rceil\). Hence, at step \(j\), the algorithm operates on qubit \ket{a_{i,j}} and bit \(b_j\).
                
                Some circuits already exist for quantum bit-string comparison. For instance \citeauthor{QBSC} and describes different circuits to do such a task in \cite{QBSC}. However, these circuits use a whole quantum register to store one of the two strings. In order to take advantage from the fact that we have a classical representation of \(b\), we build our own circuit to deal with this problem.
                
            \subsubsection{Detecting the inequality}
                The first idea for constructing the circuit is to add an ancilla qubit whose goal is to determine whether the two bits are equal:
                
                \begin{figure}[ht]
                    \centering
                    \begin{quantikz}[column sep=.6cm]
                        \lstick{\ket{a_{1,1}}} & \octrl{3}\gategroup[wires=4, steps=2, style={dashed, rounded corners,fill=blue!20, inner xsep=2pt}, background, label style={label position=below, anchor=north, yshift=-.2cm}]{Inequality detection} & \octrl{3} & \qw & \qw & \octrl{2}\gategroup[wires=4, steps=1, style={dashed, rounded corners,fill=blue!20, inner xsep=2pt}, background, label style={label position=below, anchor=north, yshift=-.2cm}]{Result computation} & \qw & \qw & \octrl{3}\gategroup[wires=4, steps=2, style={dashed, rounded corners,fill=blue!20, inner xsep=2pt}, background, label style={label position=below, anchor=north, yshift=-.2cm}]{Uncomputation} & \octrl{3} & \qw\\
                        \lstick{\ket{a_{i, j}}} & \qw & \ctrl{2} & \qw & \qw & \ctrl{1} & \qw & \qw & \ctrl{2} & \qw & \qw\\
                        \lstick{Result \ket{0}} & \qw & \qw & \qw & \qw & \gate{\X} & \qw & \qw & \qw & \qw & \qw \\
                        \lstick{Equal ancilla \ket{0}} & \gate{\X^{b_j}} & \gate{\X} & \qw & \qw & \ctrl{-1} & \qw & \qw & \gate{\X} & \gate{\X^{b_j}} & \qw
                    \end{quantikz}
                    \caption{First idea of a partial implementation of \(\mathbf{T}_\sigma\) using one ancilla qubit}
                \end{figure}
                
                By doing so, the result qubit will be in the state \(\ket{1}\) if and only if \(b_{j}<a_{i, j}\). Note that if we want the result to be \ket{1} if \(b>a_i\), when \(a_i\geqslant\frac12\) for instance, we would replace the \(\X\) gate controlled on \(a_{i,j}\) by a \(\X^{b_j}\) gate. Of course, the problem is that it will be swapped once more if this situation happens once again.
            
            \subsubsection{Maintaining the result qubit in its state once the result has been found}
                Hence, we need another ancilla qubit to know whether the circuit already has determined that \(a_i>b\). By controlling the operations on the result qubit by this new ancilla qubit, we avoid applying again a gate on it if the result is already known, as shown on the following:
                
                \begin{figure}[ht]
                    \centering
                    \begin{quantikz}[column sep=.6cm]
                        \lstick{\ket{a_{1,1}}} & \octrl{3}\gategroup[wires=5, steps=2, style={dashed, rounded corners,fill=blue!20, inner xsep=2pt}, background, label style={label position=below, anchor=north, yshift=-.2cm}]{Inequality detection} & \octrl{3} & \qw & \octrl{4}\gategroup[wires=5, steps=2, style={dashed, rounded corners,fill=blue!20, inner xsep=2pt}, background, label style={label position=below, anchor=north, yshift=-.2cm}]{Result computation} & \octrl{2} & \qw\slice{\ket{\varphi}} & \qw & \octrl{3}\gategroup[wires=5, steps=2, style={dashed, rounded corners,fill=blue!20, inner xsep=2pt}, background, label style={label position=below, anchor=north, yshift=-.2cm}]{Uncomputation} & \octrl{3} & \qw\\
                        \lstick{\ket{a_{i, j}}} & \qw & \ctrl{2} & \qw & \qw & \ctrl{1} & \qw & \qw & \ctrl{2} & \qw & \qw\\
                        \lstick{Result \ket{0}} & \qw & \qw & \qw & \qw & \gate{\X} & \qw & \qw & \qw & \qw & \qw\\
                        \lstick{Equal ancilla \ket{0}} & \gate{\X^{b_j}} & \gate{\X} & \qw & \ctrl{1} & \ctrl{-1} & \qw & \qw & \gate{\X} & \gate{\X^{b_j}} & \qw\\
                        \lstick{Result found ancilla \ket{0}} & \octrl{-1} & \octrl{-1} & \qw & \gate{\X} & \qw & \qw & \qw & \octrl{-1} & \octrl{-1} & \qw
                    \end{quantikz}
                    \caption{Second idea of a partial implementation of \(\mathbf{T}_\sigma\) using two ancilla qubits}
                \end{figure}
                
                The idea is to test for the equality between the bits only when the circuit hasn't already determined whether \(a_i>b\). But this design also has a flaw. Indeed, let us assume that the first inequality detected \(a_{i, j}\neq b_j\) is at bit \(j\). Now, we want to uncompute the state of the equal ancilla from \(\ket{1}\) to \(\ket{0}\). While the first intuition to do this is drawn on the circuit above, this implementation is incorrect. Indeed, we have:
                
                \[\ket{\varphi} = \ket{a_{i, j}}\,\ket{1^{b_j}}\,\ket{1}\,\ket{1}\]
                
                Hence, the \(\X\) and \(\X^{b_j}\) gates of the uncomputation steps won't be applied on the equal ancilla, since the result found ancilla is in the state \(\ket{1}\). Controlling on the value \ket{0} would not work either, since this would be applied at each following step, since the result found ancilla is supposed to stay in the state \ket{1}.
                
            \subsubsection{Uncomputing the equal ancilla}
                Hence, we need to add another ancilla qubit whose goal is to store whether the result is set at the beginning of a step. By controlling the uncomputation gates on this qubit, we ensure to apply them only when it is necessary. This leads to another version of the partial implementation of \(\mathbf{T}_\sigma\):
                
                \begin{figure}[ht]
                    \centering
                    \begin{quantikz}
                        \lstick{\ket{a_{1,1}}} & \octrl{3}\gategroup[wires=6, steps=2, style={dashed, rounded corners,fill=blue!20, inner xsep=2pt}, background, label style={label position=below, anchor=north, yshift=-.2cm}]{Inequality detection} & \octrl{3} & \qw & \octrl{5}\gategroup[wires=6, steps=3, style={dashed, rounded corners,fill=blue!20, inner xsep=2pt}, background, label style={label position=below, anchor=north, yshift=-.2cm}]{Result computation} & \octrl{4} & \octrl{2} & \qw & \octrl{3}\gategroup[wires=6, steps=2, style={dashed, rounded corners,fill=blue!20, inner xsep=2pt}, background, label style={label position=below, anchor=north, yshift=-.2cm}]{Uncomputation} & \octrl{3} & \qw\\
                        \lstick{\ket{a_{i, j}}} & \qw & \ctrl{2} & \qw & \qw & \qw & \ctrl{1} & \qw & \ctrl{2} & \qw & \qw\\
                        \lstick{Result \ket{0}} & \qw & \qw & \qw & \qw & \qw & \gate{\X} & \qw & \qw & \qw & \qw\\
                        \lstick{Equal ancilla \ket{0}} & \gate{\X^{b_j}} & \gate{\X} & \qw & \octrl{2} & \ctrl{1} & \ctrl{-1} & \qw & \gate{\X} & \gate{\X^{b_j}} & \qw\\
                        \lstick{Result found ancilla \ket{0}} & \octrl{-1} & \octrl{-1} & \qw & \ctrl{1} & \gate{\X} & \qw & \qw & \qw & \qw & \qw\\
                        \lstick{Result set ancilla \ket{0}} & \qw & \qw & \qw & \gate{\X} & \qw & \qw & \qw & \octrl{-2} & \octrl{-2} & \qw
                    \end{quantikz}
                    \caption{Third idea of a partial implementation of \(\mathbf{T}_\sigma\) using three ancilla qubits}
                \end{figure}
                
                But there is still one problem: at the \(j+1\) step, the ancilla will change its value again, eventually changing other registers.
            \subsubsection{Uncompute the equal qubit using more ancillas}
                To solve this problem, we can define an ancilla for every step and let them be thereafter. Then, the only need to take into account is to prove that the result qubit is not entangled with these ancillas, to ensure to have a correct measurement. Hence, we need an ancilla for every step, which can by symbolised with the following circuit:
                
                \begin{figure}[ht]
                    \centering
                    \begin{quantikz}
                        \lstick{\ket{a_{1,1}}} & \octrl{3}\gategroup[wires=6, steps=2, style={dashed, rounded corners,fill=blue!20, inner xsep=2pt}, background, label style={label position=below, anchor=north, yshift=-.2cm}]{Inequality detection} & \octrl{3} & \qw & \octrl{5}\gategroup[wires=6, steps=3, style={dashed, rounded corners,fill=blue!20, inner xsep=2pt}, background, label style={label position=below, anchor=north, yshift=-.2cm}]{Result computation} & \octrl{4} & \octrl{2} & \qw & \octrl{3}\gategroup[wires=6, steps=2, style={dashed, rounded corners,fill=blue!20, inner xsep=2pt}, background, label style={label position=below, anchor=north, yshift=-.2cm}]{Uncomputation} & \octrl{3} & \qw\\
                        \lstick{\ket{a_{i, j}}} & \qw & \ctrl{2} & \qw & \qw & \qw & \ctrl{1} & \qw & \ctrl{2} & \qw & \qw\\
                        \lstick{Result \ket{0}} & \qw & \qw & \qw & \qw & \qw & \gate{\X} & \qw & \qw & \qw & \qw\\
                        \lstick{Equal ancilla \ket{0}} & \gate{\X^{b_j}} & \gate{\X} & \qw & \octrl{2} & \ctrl{1} & \ctrl{-1} & \qw & \gate{\X} & \gate{\X^{b_j}} & \qw\\
                        \lstick{Result found ancilla \ket{0}} & \octrl{-1} & \octrl{-1} & \qw & \ctrl{1} & \gate{\X} & \qw & \qw & \qw & \qw & \qw\\
                        \lstick{Ancilla \(j\) \ket{0}} & \qw & \qw & \qw & \gate{\X} & \qw & \qw & \qw & \octrl{-2} & \octrl{-2} & \qw
                    \end{quantikz}
                    \caption{Final version of the implementation of \(\mathbf{T}_\sigma\) using \(\lceil\log(n)\rceil + 1\) ancilla qubits}
                \end{figure}
                
                Note that aside from the Equal ancilla and the Result found ancilla, we only need \(n - 1\) ancilla qubits. This is due to the fact that the very first step does not need such an ancilla qubit, since we know that the Result found ancilla will be in state \ket{0}.
                
                Plus, since every operation is controlled on \(a_{i,1}\), we can simply concatenate the two circuits to use the same ancillas for the case \(a_i>\frac12\). At every step, \(7\) controlled gates are applied. Hence, the total complexity of this circuit is linear in the number of steps it makes, that is \(O(\log(n))\).
                
                There are still two corner cases which we need to tackle, that are the cases \(a_i=\frac12\) and \(a_i=b\). If \(a_i=\frac12\), it will only be considered by the second part of the circuit. Since \(b_1<\frac12\), we know that \(b_2>\frac12\). Hence, the second part will detect that \(b_2>a_i\) and outputs the state \ket{1}, which is what we desire. Concerning the case \(a_i=b\), the circuit will never detect an inequality. Hence, it will output the state \ket{0}, which is also what we want. Indeed, as a recall, we have:
                
                \[\sigma_i < \sigma\,\left(1 - \frac\kappa2\right)\iff\begin{cases}\frac1\pi\,\arccos\left(\frac{\sigma\,\left(1 - \frac\kappa2\right)}{\|\mathbf{A}\|_F}\right) < a_i&\text{if }a_i<\frac12\\1-\frac1\pi\,\arccos\left(\frac{\sigma\,\left(1 - \frac\kappa2\right)}{\|\mathbf{A}\|_F}\right) > a_i&\text{if }a_i\geqslant\frac12\end{cases}\,.\]
                
                In particular, \(a_i=b\) implies that \(\sigma_i \geqslant \sigma\,\left(1 - \frac\kappa2\right)\). As such, the output of \(\mathbf{T}_\sigma\) is to be \ket{0}.
                
    \section{Conclusion}
    % TODO: Dequantized algorithms, number of qubits, cut in probability, acknowledgements
        In this paper, we tried to highlight the differences between a theoretical implementation of a quantum algorithm and its real-world implementation. We showed that even given some compromises, like cutting down the probability of success, some operations are for now impossible to perform.
        
        In particular, we discussed two useful concepts used in quantum subroutines: QRAM and Quantum Phase Estimation. While the former shows its true potential when implemented with a quantum access, the latter is, at our knowledge, not conveniently usable as a quantum subroutine because of the measurement it performs.
        
        We believe it is feasible to load data in the QRAM using circuits as mentioned in \cite{QRAMCircuit} but have chosen to let it for a future work. We also believe that it is possible to use the QPE algorithm without either performing the measurement or having to uncompute it, which would solve the problem.
        
        Still, it is important to keep in mind that the algorithm described has a classical equivalent described by \citeauthor{Dequantized} in \cite{Dequantized}. As such, it is very likely that this classical algorithm will be used in lieu of the quantum one, for performance reasons.
        
        Plus, we did not discuss the actual number of qubits needed to run this algorithm, nor the performance of the gates we consider. Indeed, quantum computers are known to be noisy, and quantum error correction is now both an art and a science. In order to measure the performance of a quantum computer, \citeauthor{QVolume} recently introduced the notion of Quantum Volume in \cite{QVolume}. This metric given, one can use it to objectively evaluate a quantum computer. As such, it is useful to track whenever the quantum supremacy will be observed on several other algorithms than the one used by Google in 2019 \cite{Supremacy}.
    
    \section{Acknowledgments}
        I would like to thank Mario \textsc{Berta}, both for having me introduced to the Quantum Computing field and for having been such a great supervisor in this Individual Study Option.

    \printbibliography
\end{document}
